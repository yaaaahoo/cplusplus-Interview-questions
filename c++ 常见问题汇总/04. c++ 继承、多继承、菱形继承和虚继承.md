# 继承

### 【继承中涉及的权限】

| 基类中的成员 | public继承权限 | protected继承权限 | private继承权限 |
| -- | -- | -- | -- |
| public成员 | 作为派生类的public成员存在 | 作为派生类的protected成员存在 | 作为派生类的private成员存在 |
| protected成员 | 作为派生类的protected成员存在 | 作为派生类的protected成员存在 | 作为派生类的private成员存在 |
| private成员 | 在派生类中不可见 | 在派生类中不可见 | 在派生类中不可见 |

1. 继承的权限可以被缩小，不能被放大。
2. 私有继承私有成员也被继承了，只是对子类和外界均不可见而已。但是可以在子类中通过父类的方法间接访问。

### 【友元】

父类的友元不是子类的友元。友元只对所在的类域有效。

### 【赋值兼容规则】

在公有继承中，子类可以赋值给父类，并且是天然支持的（编译器的直接行为），也没有临时变量（不是隐式类型转换）。
1. 派生类对象可以直接赋值给基类对象；
2. 派生类对象可以初始化基类引用；
3. 派生类对象的地址可以赋值给指向基类对象的指针。

### 【继承中的构造和析构顺序】

1. 继承中规定，父类的成员必须通过父类的构造函数完成初始化。因此，子类需要辅助父类进行初始化动作。
    - 子类中自动生成的构造函数会自动调用父类构造函数进行初始化；
    - 显式声明的构造函数需要再初始化列表中调用父类的构造函数辅助其完成初始化工作。
2. 先完成子类的析构，在进行父类的析构。父类的析构是自动调用的，切不可手动调用父类的析构函数，否则会进行两次析构造成未定义行为。

### 【隐藏】

1. 当子类和父类具有同名成员变量时候，父类的成员将会被隐藏。可以通过基类的类名和作用域运算符显式支持作用域，如 Base::member_;
2. 函数构成隐藏的条件：只要函数名称相同就会构成隐藏，不需要考虑返回值和参数列表。

### 【如何实现一个无法被继承的类】

1. 私有化构造函数或私有化析构函数；
2. 使用final关键字。

# 多继承

# 菱形继承

# 虚继承